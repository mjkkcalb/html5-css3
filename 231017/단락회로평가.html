<body>
  <h2>단락회로평가</h2>
  <script>
    /*
    단락평가 ( 단락회로평가) : 논리 연산자의 특성을 이용하여 평가

    truthy : 참인듯?
      ㄴ 빈배열[], 빈객체 {}...

    falsy(falsey) : 거짓인듯?
      ㄴ false, 0, -0(-1,-2,...), '', null, undefined, NaN
      
    boolean && 실행문, boolean || 실행문
      ㄴ ||연산자
        true || 조건 -> a조건이 참이면 b조건(실행문) 실행 x
        false || 조건 -> a조건이 거짓이면 b조건(실행문) 실행(내용반환)

      ㄴ && 연산자
        true && 조건 -> b조건도 참이면 실행
        false && 조건 -> a조건이 거짓이면 b조건(실행문) 실행 x
    */

    console.log(`-- && ${false && true} --`); // false
    // A의 값이 거짓인 경우 B의 값을 탐색할 필요도 없이 거짓이 되므로 falsy
    false && console.log(`A가 거짓이면 이 내용은 반환되지 않음`);
    true && console.log(`A가 참이면 이 내용은 반환됨`);
    (11 > 10) && console.log('truthy 한 상황');

    console.log(true && false && true); // false
    //A.B의 값이 false 이기 때문에 C까지 가지않고 멈춤 falsey
    console.log(11 > 10 && 11 == 10 && '출력되지 않음')
    console.log(11 > 10 && 11 != 10 && '출력')

    console.log(`-- || ${false || true} --`); //true
    // A가 true인 경우 B의 값을 탐색할 필요가 없으므로 반환되지 않음. truthy
    true || console.log(`A가 참이면 이 내용은 반환되지 않음`)
    false || console.log(`A가 거짓이면 이 내용은 반환됨`)

    console.log(false || true || true); // true
    // A와 B 먼저 연산 후 결과값을 C와 연산
    // A와 B를 읽어 true가 나오면 C의 값을 탐색할 필요가 없으므로 멈춤

    console.log('' || 'a'); //a . 빈 문자열은 falsy의 값이므로 뒤의 값을 읽음
    console.log('' || '여기서 멈춤' || 222); //A가 거짓이면 B를 읽고 B가 참이면 or 연산자는 truthy 때문에 거기서 멈춤

    console.log([] && '' && 222);
    // A가 truthy이고 B가 falsey이면 AND 연산자는 true에서 멈춤
    // [] <- 빈 배열로 truthy

    console.log([] && {} && 222); //222
  </script>
</body>